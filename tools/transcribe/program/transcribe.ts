import nodePath from 'node:path';
import {
  getMarkdownContent,
  type PostMatter,
  writePost,
} from '#common/markdown/markdown.ts';
import { AssemblyAIProvider } from '#transcribe/provider/assemblyai/AssemblyAIProvider.ts';
import { GladiaProvider } from '#transcribe/provider/gladia/GladiaProvider.ts';

interface TranscribeOptions {
  provider?: TypeProvider;
  timestamps?: boolean;
  gap?: number;
}

export const Provider = {
  ASSEMBLYAI: 'assemblyai',
  GLADIA: 'gladia',
} as const;

export type TypeProvider = (typeof Provider)[keyof typeof Provider];

const providers = {
  [Provider.ASSEMBLYAI]: AssemblyAIProvider,
  [Provider.GLADIA]: GladiaProvider,
} as const;

export async function transcribe(path: string, options: TranscribeOptions) {
  const {
    provider = Provider.ASSEMBLYAI,
    timestamps = true,
    gap = 10,
  } = options;
  const { frontMatter, content } = getMarkdownContent<PostMatter>(path);

  if (frontMatter.type !== 'post') {
    console.error('Markdown is not a post');
    process.exit(1);
  }
  if (content.length !== 0) {
    console.error('Error: Content is not empty');
    process.exit(1);
  }

  const { audio, lang } = frontMatter;
  const audioPath = nodePath.resolve(nodePath.dirname(path), audio.file);

  const transcriptService = new providers[provider]();
  const transcript = await transcriptService.transcribe(
    audioPath,
    lang,
    timestamps,
    gap
  );

  const newContent =
    `<strong>Auto-generated by ${transcriptService.getName()}. Review and edit.</strong>` +
    '\n\n' +
    transcript;

  const newMarkdown = {
    frontMatter,
    content: newContent,
  };

  writePost(path, newMarkdown);
}
